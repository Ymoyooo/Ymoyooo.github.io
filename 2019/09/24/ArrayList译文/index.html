<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="/*  Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved. ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.          */  package java.util; import java.util.func">
<meta property="og:type" content="article">
<meta property="og:title" content="机智">
<meta property="og:url" content="http://yoursite.com/2019/09/24/ArrayList译文/index.html">
<meta property="og:site_name" content="机智">
<meta property="og:description" content="/*  Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved. ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.          */  package java.util; import java.util.func">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-09-30T10:09:16.213Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="机智">
<meta name="twitter:description" content="/*  Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved. ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.          */  package java.util; import java.util.func">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/24/ArrayList译文/">





  <title> | 机智</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">机智</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/ArrayList译文/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ymon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="机智">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-24T22:20:23+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  44
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>/*</p>
<ul>
<li>Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</li>
<li>ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.<br><em>
</em><br><em>
</em><br><em>
</em><br><em>
</em><br><em>
</em><br><em>
</em><br><em>
</em><br><em>
</em><br><em>
</em><br><em>
</em><br>*/</li>
</ul>
<p>package java.util;</p>
<p>import java.util.function.Consumer;<br>import java.util.function.Predicate;<br>import java.util.function.UnaryOperator;<br>import sun.misc.SharedSecrets;</p>
<p>/**</p>
<ul>
<li>Resizable-array implementation of the <tt>List</tt> interface.  Implements</li>
<li>all optional list operations, and permits all elements, including</li>
<li><tt>null</tt>.  In addition to implementing the <tt>List</tt> interface,</li>
<li>this class provides methods to manipulate the size of the array that is</li>
<li>used internally to store the list.  (This class is roughly equivalent to</li>
<li><tt>Vector</tt>, except that it is unsynchronized.)<br>*</li>
<li><p>The <tt>size</tt>, <tt>isEmpty</tt>, <tt>get</tt>, <tt>set</tt>,</p></li>
<li><tt>iterator</tt>, and <tt>listIterator</tt> operations run in constant</li>
<li>time.  The <tt>add</tt> operation runs in <i>amortized constant time</i>,</li>
<li>that is, adding n elements requires O(n) time.  All of the other operations</li>
<li>run in linear time (roughly speaking).  The constant factor is low compared</li>
<li>to that for the <tt>LinkedList</tt> implementation.<br>*</li>
<li><p>Each <tt>ArrayList</tt> instance has a <i>capacity</i>.  The capacity is</p></li>
<li>the size of the array used to store the elements in the list.  It is always</li>
<li>at least as large as the list size.  As elements are added to an ArrayList,</li>
<li>its capacity grows automatically.  The details of the growth policy are not</li>
<li>specified beyond the fact that adding an element has constant amortized</li>
<li>time cost.<br>*</li>
<li><p>An application can increase the capacity of an <tt>ArrayList</tt> instance</p></li>
<li>before adding a large number of elements using the <tt>ensureCapacity</tt></li>
<li>operation.  This may reduce the amount of incremental reallocation.<br>*</li>
<li><p><strong>Note that this implementation is not synchronized.</strong></p></li>
<li>If multiple threads access an <tt>ArrayList</tt> instance concurrently,</li>
<li>and at least one of the threads modifies the list structurally, it</li>
<li><i>must</i> be synchronized externally.  (A structural modification is</li>
<li>any operation that adds or deletes one or more elements, or explicitly</li>
<li>resizes the backing array; merely setting the value of an element is not</li>
<li>a structural modification.)  This is typically accomplished by</li>
<li>synchronizing on some object that naturally encapsulates the list.<br>*</li>
<li>If no such object exists, the list should be “wrapped” using the</li>
<li>{@link Collections#synchronizedList Collections.synchronizedList}</li>
<li>method.  This is best done at creation time, to prevent accidental</li>
<li>unsynchronized access to the list:<pre></pre></li>
<li>List list = Collections.synchronizedList(new ArrayList(…));<br>*</li>
<li><p><a name="fail-fast"></a></p></li>
<li>The iterators returned by this class’s {@link #iterator() iterator} and</li>
<li>{@link #listIterator(int) listIterator} methods are <em>fail-fast</em>:</li>
<li>if the list is structurally modified at any time after the iterator is</li>
<li>created, in any way except through the iterator’s own</li>
<li>{@link ListIterator#remove() remove} or</li>
<li>{@link ListIterator#add(Object) add} methods, the iterator will throw a</li>
<li>{@link ConcurrentModificationException}.  Thus, in the face of</li>
<li>concurrent modification, the iterator fails quickly and cleanly, rather</li>
<li>than risking arbitrary, non-deterministic behavior at an undetermined</li>
<li>time in the future.<br>*</li>
<li><p>Note that the fail-fast behavior of an iterator cannot be guaranteed</p></li>
<li>as it is, generally speaking, impossible to make any hard guarantees in the</li>
<li>presence of unsynchronized concurrent modification.  Fail-fast iterators</li>
<li>throw {@code ConcurrentModificationException} on a best-effort basis.</li>
<li>Therefore, it would be wrong to write a program that depended on this</li>
<li>exception for its correctness:  <i>the fail-fast behavior of iterators</i></li>
<li>should be used only to detect bugs.<br>*</li>
<li><p>This class is a member of the</p></li>
<li><a href="{@docRoot}/../technotes/guides/collections/index.html"></a></li>
<li>Java Collections Framework.<br>*</li>
<li>@author  Josh Bloch</li>
<li>@author  Neal Gafter</li>
<li>@see     Collection</li>
<li>@see     List</li>
<li>@see     LinkedList</li>
<li>@see     Vector</li>
<li>@since   1.2<br>*/</li>
</ul>
<p>public class ArrayList<e> extends AbstractList<e><br>        implements List<e>, RandomAccess, Cloneable, java.io.Serializable<br>{<br>    //序列化后获得的UID<br>    private static final long serialVersionUID = 8683452581122892189L;</e></e></e></p>
<pre><code>/**
 * 默认初始化容量
 */
/**
 * 当初始化容量为0的时候,就创建空的对象数组
 */
private static final int DEFAULT_CAPACITY = 10;

/**
 * 当初始化容量为0的时候,就创建空的对象数组
 */
private static final Object[] EMPTY_ELEMENTDATA = {};

/**
 * Shared empty array instance used for default sized empty instances. We
 * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
 * first element is added.
 * 当使用new Array()的时候就是使用这个创建的空数组,与EMPTY_ELEMENTDATA的区别就是
 * 这个数组添加第一个元素后初始化容量是10,后者的则不清楚.
 */
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

/**
 * The array buffer into which the elements of the ArrayList are stored.
 * The capacity of the ArrayList is the length of this array buffer. Any
 * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
 * will be expanded to DEFAULT_CAPACITY when the first element is added.
 * 这个数组就是储存元素的对象数组.
 * 如果是通过new ArrayList()创建的话,添加第一个元素时数组就会自动扩展成默认容量大小.
 * 默认容量是10 
 */
transient Object[] elementData; // non-private to simplify nested class access

/**
 * The size of the ArrayList (the number of elements it contains).
 * 集合中元素的个数.
 * @serial
 */
private int size;

/**
 * Constructs an empty list with the specified initial capacity.
 * 构建一个指定长度的空数组.
 * 
 * @param  initialCapacity  the initial capacity of the list
 * initialCapacity代表的是列表指定的初始化容量
 * 
 * @throws IllegalArgumentException if the specified initial capacity
 *         is negative
 * 当传入的值为负值的时候就会报错,并把错误数字传出
 * 
 */
public ArrayList(int initialCapacity) {
    if (initialCapacity &gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    }
}

/**
 * Constructs an empty list with an initial capacity of ten.
 * 创建一个默认长度(10)的空数组
 */
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

/**
 * Constructs a list containing the elements of the specified
 * collection, in the order they are returned by the collection&apos;s
 * iterator.
 * 按照特定集合迭代器返回的顺序,去构建一个对应长度的数组
 *
 * @param c the collection whose elements are to be placed into this list
 * c代表的就是准备转换成list的集合
 * 
 * @throws NullPointerException if the specified collection is null
 * 如果集合为null就会抛出错误NullPointerException
 */
public ArrayList(Collection&lt;? extends E&gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}

/**
 * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the
 * list&apos;s current size.  An application can use this operation to minimize
 * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance.
 * 把list的容量缩小至当前数组的size,即实际存储有效数据使用空间.
 * 使用此方法去最小化一个ArrayList实例
 * 
 */
public void trimToSize() {
    modCount++;
    if (size &lt; elementData.length) {
        elementData = (size == 0)
          ? EMPTY_ELEMENTDATA
          : Arrays.copyOf(elementData, size);
    }
}

/**
 * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if
 * necessary, to ensure that it can hold at least the number of elements
 * specified by the minimum capacity argument.
 * 传入一个扩大的值,扩大ArrayList的转载空间.
 * 如果数组是通过new ArrayList(0)创建的话,传入参数&lt;10按10来扩容,传入参数&gt;10就按参数大小来扩容.
 * 如果数组是通过new ArrayList()创建,按传入参数来扩容.
 *
 * @param   minCapacity   the desired minimum capacity
 */
public void ensureCapacity(int minCapacity) {
    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
        // any size if not default element table
        ? 0
        // larger than default for default empty table. It&apos;s already
        // supposed to be at default size.
        : DEFAULT_CAPACITY;

    if (minCapacity &gt; minExpand) {
        ensureExplicitCapacity(minCapacity);
    }
}

private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}

private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

/**
 * The maximum size of array to allocate.
 * Some VMs reserve some header words in an array.
 * Attempts to allocate larger arrays may result in
 * OutOfMemoryError: Requested array size exceeds VM limit
 * arrayList最大的扩容值.因为有的虚拟机实现过程中会使用一部分容量储存其余数据
 * 所以如果使用全部可能会导致OOM异常.
 */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

/**
 * Increases the capacity to ensure that it can hold at least the
 * number of elements specified by the minimum capacity argument.
 * 当要扩大容量的时候会传入一个min容量,默认数组是会扩容至原数组的1.5倍大小
 * 如果原容量加入要扩大的容量是大于原容量的1.5倍,而且(原容量+扩大容量)&lt;=最大支持扩容值,
 * 那么将会扩容到(原容量+需扩大容量)的大小的。
 * 如果目标扩大容量小于原容量的1.5倍的话，那么是按照1.5倍来扩大的。
 * 如果扩大后的容量是＞最大支持扩容量，就按照Integer.MAX_VALUE来扩容
 * @param minCapacity the desired minimum capacity
 */
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}

/**
 * Returns the number of elements in this list.
 * 返回元素的个数 ps.不是返回容量的大小。
 * @return the number of elements in this list
 */
public int size() {
    return size;
}

/**
 * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements.
 * 如果list里面没有元素就返回0
 * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains no elements
 */
public boolean isEmpty() {
    return size == 0;
}

/**
 * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element.
 * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains
 * at least one element &lt;tt&gt;e&lt;/tt&gt; such that
 * &lt;tt&gt;(o==null ? e==null : o.equals(e))&lt;/tt&gt;.
 * 检查list里面是否存在o元素，存在就返回true,否则返回false
 * @param o element whose presence in this list is to be tested
 * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element
 */
public boolean contains(Object o) {
    return indexOf(o) &gt;= 0;
}

/**
 * Returns the index of the first occurrence of the specified element
 * in this list, or -1 if this list does not contain the element.
 * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that
 * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,
 * or -1 if there is no such index.
 * 将从list的头个元素开始查找，当查找到匹配元素时，将返回他的下标。
 * 如果直到最后都没有匹配成功，将返回-1
 */
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i &lt; size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i &lt; size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

/**
 * Returns the index of the last occurrence of the specified element
 * in this list, or -1 if this list does not contain the element.
 * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that
 * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,
 * or -1 if there is no such index.
 * 将从list的尾部开始查找，当查找到匹配元素时，将返回他的下标。
 * 如果直到查找至头部都没有匹配成功的话，将返回-1
 */
public int lastIndexOf(Object o) {
    if (o == null) {
        for (int i = size-1; i &gt;= 0; i--)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = size-1; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

/**
 * Returns a shallow copy of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance.  (The
 * elements themselves are not copied.)
 * 对arraylist进行一个浅拷贝，就是相当于与别人共用一组元素。返回一个引用
 *
 * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance
 */
public Object clone() {
    try {
        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
        v.elementData = Arrays.copyOf(elementData, size);
        v.modCount = 0;
        return v;
    } catch (CloneNotSupportedException e) {
        // this shouldn&apos;t happen, since we are Cloneable
        throw new InternalError(e);
    }
}

/**
 * Returns an array containing all of the elements in this list
 * in proper sequence (from first to last element).
 * 返回一个按故有顺序的数组
 *  
 *
 * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are
 * maintained by this list.  (In other words, this method must allocate
 * a new array).  The caller is thus free to modify the returned array.
 * 返回的数组是“安全”的，arraylist中不会存有到数组的引用。换句话说，这个方法要求
 * 重新分配一个新的数组用来容纳元素。用户可以随意编辑，不用担心修改到了list中的内容。
 *
 * &lt;p&gt;This method acts as bridge between array-based and collection-based
 * APIs.
 *
 * @return an array containing all of the elements in this list in
 *         proper sequence
 * 
 */
public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}

/**
 * Returns an array containing all of the elements in this list in proper
 * sequence (from first to last element); the runtime type of the returned
 * array is that of the specified array.  If the list fits in the
 * specified array, it is returned therein.  Otherwise, a new array is
 * allocated with the runtime type of the specified array and the size of
 * this list.
 * 返回一个按照list原有顺序排列的数组。如果传入的数组可以容纳下list，那么list将会装载进去数组
 * 如果传入的数组大小不够，就会按照list的长度创建并返回一个指定类型的数组。
 *
 * &lt;p&gt;If the list fits in the specified array with room to spare
 * (i.e., the array has more elements than the list), the element in
 * the array immediately following the end of the collection is set to
 * &lt;tt&gt;null&lt;/tt&gt;.  (This is useful in determining the length of the
 * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain
 * any null elements.)
 *
 * @param a the array into which the elements of the list are to
 *          be stored, if it is big enough; otherwise, a new array of the
 *          same runtime type is allocated for this purpose.
 * @return an array containing the elements of the list
 * @throws ArrayStoreException if the runtime type of the specified array
 *         is not a supertype of the runtime type of every element in
 *         this list
 * @throws NullPointerException if the specified array is null
 */
@SuppressWarnings(&quot;unchecked&quot;)
public &lt;T&gt; T[] toArray(T[] a) {
    if (a.length &lt; size)
        // Make a new array of a&apos;s runtime type, but my contents:
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length &gt; size)
        a[size] = null;
    return a;
}

// Positional Access Operations


@SuppressWarnings(&quot;unchecked&quot;)
E elementData(int index) {
    return (E) elementData[index];
}

/**
 * Returns the element at the specified position in this list.
 * 把list中指定位置的元素返回
 *
 * @param  index index of the element to return
 * @return the element at the specified position in this list
 * 会检查下标是否越界，如果是就会返回一个outofBounds错误
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E get(int index) {
    rangeCheck(index);

    return elementData(index);
}

/**
 * Replaces the element at the specified position in this list with
 * the specified element.
 * 把一个指定的值替换到list里面一个指定的位置中
 *
 * @param index index of the element to replace
 * 会检查index是否越界
 * @param element element to be stored at the specified position
 * 会返回被替换的值
 * @return the element previously at the specified position
 * 
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E set(int index, E element) {
    rangeCheck(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
}

/**
 * Appends the specified element to the end of this list.
 * 添加一个元素到数组的最后面
 * @param e element to be appended to this list
 * 当添加的时候会检测是否需要扩容
 * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

/**
 * Inserts the specified element at the specified position in this
 * list. Shifts the element currently at that position (if any) and
 * any subsequent elements to the right (adds one to their indices).
 * 把原有指定位置与其后面的全部数据都往后移一个位置，把数据插入到该指定位置。
 * 会检查指定的位置是否合法
 * @param index index at which the specified element is to be inserted
 * @param element element to be inserted
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}

/**
 * Removes the element at the specified position in this list.
 * Shifts any subsequent elements to the left (subtracts one from their
 * indices).
 * 删除掉指定位置的元素，并把后面的元素往前挪一位。
 * 返回被删除的元素
 * @param index the index of the element to be removed
 * @return the element that was removed from the list
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}

/**
 * Removes the first occurrence of the specified element from this list,
 * if it is present.  If the list does not contain the element, it is
 * unchanged.  More formally, removes the element with the lowest index
 * &lt;tt&gt;i&lt;/tt&gt; such that
 * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;
 * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list
 * contained the specified element (or equivalently, if this list
 * changed as a result of the call).
 * 删除掉元素内首个与传入参数匹配相等的值。
 * 元素存在并删除了会返回true，失败将返回true。
 * @param o element to be removed from this list, if present
 * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element
 */
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}

/*
 * Private remove method that skips bounds checking and does not
 * return the value removed.
 * 快速删除将不会检查下标是否越界，而且不会返回被删除的值。
 */
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}

/**
 * Removes all of the elements from this list.  The list will
 * be empty after this call returns.
 * 给list中的全部元素附上null值
 */
public void clear() {
    modCount++;

    // clear to let GC do its work
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}

/**
 * Appends all of the elements in the specified collection to the end of
 * this list, in the order that they are returned by the
 * specified collection&apos;s Iterator.  The behavior of this operation is
 * undefined if the specified collection is modified while the operation
 * is in progress.  (This implies that the behavior of this call is
 * undefined if the specified collection is this list, and this
 * list is nonempty.)
 * 会把集合中的元素按照Iterator迭代的顺序，添加进去list里面。
 * 添加前会对list的size进行一次扩容。
 *
 * @param c collection 
 * ing elements to be added to this list
 * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call
 * @throws NullPointerException if the specified collection is null
 */
public boolean addAll(Collection&lt;? extends E&gt; c) {
    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount
    System.arraycopy(a, 0, elementData, size, numNew);
    size += numNew;
    return numNew != 0;
}

/**
 * Inserts all of the elements in the specified collection into this
 * list, starting at the specified position.  Shifts the element
 * currently at that position (if any) and any subsequent elements to
 * the right (increases their indices).  The new elements will appear
 * in the list in the order that they are returned by the
 * specified collection&apos;s iterator.
 * 把传入的集合参入到制定的位置，把指定位置及指定位置后面的元素一同往后挪出一个
 * 足以容纳下存入集合大小的长度。存入的集合的顺序会按照其迭代器迭代的顺序摆放。
 *
 * @param index index at which to insert the first element from the
 *              specified collection
 * @param c collection containing elements to be added to this list
 * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call
 * @throws IndexOutOfBoundsException {@inheritDoc}
 * @throws NullPointerException if the specified collection is null
 */
public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    rangeCheckForAdd(index);

    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount

    int numMoved = size - index;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,
                         numMoved);

    System.arraycopy(a, 0, elementData, index, numNew);
    size += numNew;
    return numNew != 0;
}

/**
 * Removes from this list all of the elements whose index is between
 * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
 * Shifts any succeeding elements to the left (reduces their index).
 * This call shortens the list by {@code (toIndex - fromIndex)} elements.
 * (If {@code toIndex==fromIndex}, this operation has no effect.)
 * 本方法传入了两个参数，分别是下标index1,index2。本方法删除的元素是[index1,index2)。
 * 是通过把[index2,size-1]的元素放到了[index1,size-index2]的位置去。
 * 把移动后，无用的数据全部赋值为null。方便GC的收集。
 * @throws IndexOutOfBoundsException if {@code fromIndex} or
 *         {@code toIndex} is out of range
 *         ({@code fromIndex &lt; 0 ||
 *          fromIndex &gt;= size() ||
 *          toIndex &gt; size() ||
 *          toIndex &lt; fromIndex})
 */
protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    int numMoved = size - toIndex;
    System.arraycopy(elementData, toIndex, elementData, fromIndex,
                     numMoved);

    // clear to let GC do its work
    int newSize = size - (toIndex-fromIndex);
    for (int i = newSize; i &lt; size; i++) {
        elementData[i] = null;
    }
    size = newSize;
}

/**
 * Checks if the given index is in range.  If not, throws an appropriate
 * runtime exception.  This method does *not* check if the index is
 * negative: It is always used immediately prior to an array access,
 * which throws an ArrayIndexOutOfBoundsException if index is negative.
 * 检查传入的下标是否在合法的范围内，如果是超出了list长度，就会抛出一个越界异常
 */
private void rangeCheck(int index) {
    if (index &gt;= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

/**
 * A version of rangeCheck used by add and addAll.
 * 给插入方法使用的检查是否越界函数，越界时返回一个越界异常。
 */
private void rangeCheckForAdd(int index) {
    if (index &gt; size || index &lt; 0)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

/**
 * Constructs an IndexOutOfBoundsException detail message.
 * Of the many possible refactorings of the error handling code,
 * this &quot;outlining&quot; performs best with both server and client VMs.
 * 当发生越界异常的时候会返回一条信息显示list的长度和传入下标的值。
 */
private String outOfBoundsMsg(int index) {
    return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
}

/**
 * Removes from this list all of its elements that are contained in the
 * specified collection.
 * 这个方法就是求差集，在list中查找传入集合内的元素，如果找到相同的就会删除掉。
 * 通过覆盖以及最后的赋null值实现删除的效果
 * 传入集合会检查是否是null 如果是null会抛出一个空指针异常。
 * @param c collection containing elements to be removed from this list
 * @return {@code true} if this list changed as a result of the call
 * @throws ClassCastException if the class of an element of this list
 *         is incompatible with the specified collection
 * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 * @throws NullPointerException if this list contains a null element and the
 *         specified collection does not permit null elements
 * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 *         or if the specified collection is null
 * @see Collection#contains(Object)
 */
public boolean removeAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    return batchRemove(c, false);
}

/**
 * Retains only the elements in this list that are contained in the
 * specified collection.  In other words, removes from this list all
 * of its elements that are not contained in the specified collection.
 * 这个方法是求list与传入参数的并集，保留一起拥有的值。
 * 通过覆盖以及最后的赋null值实现删除的效果
 * 传入集合会检查是否是null 如果是null会抛出一个空指针异常。
 *
 * @param c collection containing elements to be retained in this list
 * @return {@code true} if this list changed as a result of the call
 * @throws ClassCastException if the class of an element of this list
 *         is incompatible with the specified collection
 * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
 * @throws NullPointerException if this list contains a null element and the
 *         specified collection does not permit null elements
 * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;),
 *         or if the specified collection is null
 * @see Collection#contains(Object)
 */
public boolean retainAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    return batchRemove(c, true);
}

private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
    final Object[] elementData = this.elementData;
    int r = 0, w = 0;
    boolean modified = false;
    try {
        for (; r &lt; size; r++)
            if (c.contains(elementData[r]) == complement)
                elementData[w++] = elementData[r];
    } finally {
        // Preserve behavioral compatibility with AbstractCollection,
        // even if c.contains() throws.
        if (r != size) {
            System.arraycopy(elementData, r,
                             elementData, w,
                             size - r);
            w += size - r;
        }
        if (w != size) {
            // clear to let GC do its work
            for (int i = w; i &lt; size; i++)
                elementData[i] = null;
            modCount += size - w;
            size = w;
            modified = true;
        }
    }
    return modified;
}

/**
 * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that
 * is, serialize it).
 * 把arraylist实例转换成流。
 *
 * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;
 *             instance is emitted (int), followed by all of its elements
 *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.
 */
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}

/**
 * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,
 * deserialize it).
 */
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &gt; 0) {
        // be like clone(), allocate array based upon size not capacity
        int capacity = calculateCapacity(elementData, size);
        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}

/**
 * Returns a list iterator over the elements in this list (in proper
 * sequence), starting at the specified position in the list.
 * The specified index indicates the first element that would be
 * returned by an initial call to {@link ListIterator#next next}.
 * An initial call to {@link ListIterator#previous previous} would
 * return the element with the specified index minus one.
 *
 * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public ListIterator&lt;E&gt; listIterator(int index) {
    if (index &lt; 0 || index &gt; size)
        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);
    return new ListItr(index);
}

/**
 * Returns a list iterator over the elements in this list (in proper
 * sequence).
 *
 * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 *
 * @see #listIterator(int)
 */
public ListIterator&lt;E&gt; listIterator() {
    return new ListItr(0);
}

/**
 * Returns an iterator over the elements in this list in proper sequence.
 *
 * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.
 *
 * @return an iterator over the elements in this list in proper sequence
 */
public Iterator&lt;E&gt; iterator() {
    return new Itr();
}

/**
 * An optimized version of AbstractList.Itr
 */
private class Itr implements Iterator&lt;E&gt; {
    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;

    Itr() {}

    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public E next() {
        checkForComodification();
        int i = cursor;
        if (i &gt;= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }

    public void remove() {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i &gt;= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size &amp;&amp; modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }

    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}

/**
 * An optimized version of AbstractList.ListItr
 */
private class ListItr extends Itr implements ListIterator&lt;E&gt; {
    ListItr(int index) {
        super();
        cursor = index;
    }

    public boolean hasPrevious() {
        return cursor != 0;
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor - 1;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public E previous() {
        checkForComodification();
        int i = cursor - 1;
        if (i &lt; 0)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i;
        return (E) elementData[lastRet = i];
    }

    public void set(E e) {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.set(lastRet, e);
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    public void add(E e) {
        checkForComodification();

        try {
            int i = cursor;
            ArrayList.this.add(i, e);
            cursor = i + 1;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
}

/**
 * Returns a view of the portion of this list between the specified
 * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If
 * {@code fromIndex} and {@code toIndex} are equal, the returned list is
 * empty.)  The returned list is backed by this list, so non-structural
 * changes in the returned list are reflected in this list, and vice-versa.
 * The returned list supports all of the optional list operations.
 *
 * &lt;p&gt;This method eliminates the need for explicit range operations (of
 * the sort that commonly exist for arrays).  Any operation that expects
 * a list can be used as a range operation by passing a subList view
 * instead of a whole list.  For example, the following idiom
 * removes a range of elements from a list:
 * &lt;pre&gt;
 *      list.subList(from, to).clear();
 * &lt;/pre&gt;
 * Similar idioms may be constructed for {@link #indexOf(Object)} and
 * {@link #lastIndexOf(Object)}, and all of the algorithms in the
 * {@link Collections} class can be applied to a subList.
 *
 * &lt;p&gt;The semantics of the list returned by this method become undefined if
 * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in
 * any way other than via the returned list.  (Structural modifications are
 * those that change the size of this list, or otherwise perturb it in such
 * a fashion that iterations in progress may yield incorrect results.)
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 * @throws IllegalArgumentException {@inheritDoc}
 */
public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    subListRangeCheck(fromIndex, toIndex, size);
    return new SubList(this, 0, fromIndex, toIndex);
}

static void subListRangeCheck(int fromIndex, int toIndex, int size) {
    if (fromIndex &lt; 0)
        throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);
    if (toIndex &gt; size)
        throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);
    if (fromIndex &gt; toIndex)
        throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +
                                           &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
}

private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {
    private final AbstractList&lt;E&gt; parent;
    private final int parentOffset;
    private final int offset;
    int size;

    SubList(AbstractList&lt;E&gt; parent,
            int offset, int fromIndex, int toIndex) {
        this.parent = parent;
        this.parentOffset = fromIndex;
        this.offset = offset + fromIndex;
        this.size = toIndex - fromIndex;
        this.modCount = ArrayList.this.modCount;
    }

    public E set(int index, E e) {
        rangeCheck(index);
        checkForComodification();
        E oldValue = ArrayList.this.elementData(offset + index);
        ArrayList.this.elementData[offset + index] = e;
        return oldValue;
    }

    public E get(int index) {
        rangeCheck(index);
        checkForComodification();
        return ArrayList.this.elementData(offset + index);
    }

    public int size() {
        checkForComodification();
        return this.size;
    }

    public void add(int index, E e) {
        rangeCheckForAdd(index);
        checkForComodification();
        parent.add(parentOffset + index, e);
        this.modCount = parent.modCount;
        this.size++;
    }

    public E remove(int index) {
        rangeCheck(index);
        checkForComodification();
        E result = parent.remove(parentOffset + index);
        this.modCount = parent.modCount;
        this.size--;
        return result;
    }

    protected void removeRange(int fromIndex, int toIndex) {
        checkForComodification();
        parent.removeRange(parentOffset + fromIndex,
                           parentOffset + toIndex);
        this.modCount = parent.modCount;
        this.size -= toIndex - fromIndex;
    }

    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return addAll(this.size, c);
    }

    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        rangeCheckForAdd(index);
        int cSize = c.size();
        if (cSize==0)
            return false;

        checkForComodification();
        parent.addAll(parentOffset + index, c);
        this.modCount = parent.modCount;
        this.size += cSize;
        return true;
    }

    public Iterator&lt;E&gt; iterator() {
        return listIterator();
    }

    public ListIterator&lt;E&gt; listIterator(final int index) {
        checkForComodification();
        rangeCheckForAdd(index);
        final int offset = this.offset;

        return new ListIterator&lt;E&gt;() {
            int cursor = index;
            int lastRet = -1;
            int expectedModCount = ArrayList.this.modCount;

            public boolean hasNext() {
                return cursor != SubList.this.size;
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public E next() {
                checkForComodification();
                int i = cursor;
                if (i &gt;= SubList.this.size)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i + 1;
                return (E) elementData[offset + (lastRet = i)];
            }

            public boolean hasPrevious() {
                return cursor != 0;
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public E previous() {
                checkForComodification();
                int i = cursor - 1;
                if (i &lt; 0)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i;
                return (E) elementData[offset + (lastRet = i)];
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {
                Objects.requireNonNull(consumer);
                final int size = SubList.this.size;
                int i = cursor;
                if (i &gt;= size) {
                    return;
                }
                final Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length) {
                    throw new ConcurrentModificationException();
                }
                while (i != size &amp;&amp; modCount == expectedModCount) {
                    consumer.accept((E) elementData[offset + (i++)]);
                }
                // update once at end of iteration to reduce heap write traffic
                lastRet = cursor = i;
                checkForComodification();
            }

            public int nextIndex() {
                return cursor;
            }

            public int previousIndex() {
                return cursor - 1;
            }

            public void remove() {
                if (lastRet &lt; 0)
                    throw new IllegalStateException();
                checkForComodification();

                try {
                    SubList.this.remove(lastRet);
                    cursor = lastRet;
                    lastRet = -1;
                    expectedModCount = ArrayList.this.modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            public void set(E e) {
                if (lastRet &lt; 0)
                    throw new IllegalStateException();
                checkForComodification();

                try {
                    ArrayList.this.set(offset + lastRet, e);
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            public void add(E e) {
                checkForComodification();

                try {
                    int i = cursor;
                    SubList.this.add(i, e);
                    cursor = i + 1;
                    lastRet = -1;
                    expectedModCount = ArrayList.this.modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            final void checkForComodification() {
                if (expectedModCount != ArrayList.this.modCount)
                    throw new ConcurrentModificationException();
            }
        };
    }

    public List&lt;E&gt; subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, offset, fromIndex, toIndex);
    }

    private void rangeCheck(int index) {
        if (index &lt; 0 || index &gt;= this.size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private void rangeCheckForAdd(int index) {
        if (index &lt; 0 || index &gt; this.size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private String outOfBoundsMsg(int index) {
        return &quot;Index: &quot;+index+&quot;, Size: &quot;+this.size;
    }

    private void checkForComodification() {
        if (ArrayList.this.modCount != this.modCount)
            throw new ConcurrentModificationException();
    }

    public Spliterator&lt;E&gt; spliterator() {
        checkForComodification();
        return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset,
                                           offset + this.size, this.modCount);
    }
}

@Override
public void forEach(Consumer&lt;? super E&gt; action) {
    Objects.requireNonNull(action);
    final int expectedModCount = modCount;
    @SuppressWarnings(&quot;unchecked&quot;)
    final E[] elementData = (E[]) this.elementData;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        action.accept(elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}

/**
 * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;
 * and &lt;em&gt;fail-fast&lt;/em&gt; {@link Spliterator} over the elements in this
 * list.
 *
 * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#SIZED},
 * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
 * Overriding implementations should document the reporting of additional
 * characteristic values.
 *
 * @return a {@code Spliterator} over the elements in this list
 * @since 1.8
 */
@Override
public Spliterator&lt;E&gt; spliterator() {
    return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0);
}

/** Index-based split-by-two, lazily initialized Spliterator */
static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; {

    /*
     * If ArrayLists were immutable, or structurally immutable (no
     * adds, removes, etc), we could implement their spliterators
     * with Arrays.spliterator. Instead we detect as much
     * interference during traversal as practical without
     * sacrificing much performance. We rely primarily on
     * modCounts. These are not guaranteed to detect concurrency
     * violations, and are sometimes overly conservative about
     * within-thread interference, but detect enough problems to
     * be worthwhile in practice. To carry this out, we (1) lazily
     * initialize fence and expectedModCount until the latest
     * point that we need to commit to the state we are checking
     * against; thus improving precision.  (This doesn&apos;t apply to
     * SubLists, that create spliterators with current non-lazy
     * values).  (2) We perform only a single
     * ConcurrentModificationException check at the end of forEach
     * (the most performance-sensitive method). When using forEach
     * (as opposed to iterators), we can normally only detect
     * interference after actions, not before. Further
     * CME-triggering checks apply to all other possible
     * violations of assumptions for example null or too-small
     * elementData array given its size(), that could only have
     * occurred due to interference.  This allows the inner loop
     * of forEach to run without any further checks, and
     * simplifies lambda-resolution. While this does entail a
     * number of checks, note that in the common case of
     * list.stream().forEach(a), no checks or other computation
     * occur anywhere other than inside forEach itself.  The other
     * less-often-used methods cannot take advantage of most of
     * these streamlinings.
     */

    private final ArrayList&lt;E&gt; list;
    private int index; // current index, modified on advance/split
    private int fence; // -1 until used; then one past last index
    private int expectedModCount; // initialized when fence set

    /** Create new spliterator covering the given  range */
    ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence,
                         int expectedModCount) {
        this.list = list; // OK if null unless traversed
        this.index = origin;
        this.fence = fence;
        this.expectedModCount = expectedModCount;
    }

    private int getFence() { // initialize fence to size on first use
        int hi; // (a specialized variant appears in method forEach)
        ArrayList&lt;E&gt; lst;
        if ((hi = fence) &lt; 0) {
            if ((lst = list) == null)
                hi = fence = 0;
            else {
                expectedModCount = lst.modCount;
                hi = fence = lst.size;
            }
        }
        return hi;
    }

    public ArrayListSpliterator&lt;E&gt; trySplit() {
        int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
        return (lo &gt;= mid) ? null : // divide range in half unless too small
            new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,
                                        expectedModCount);
    }

    public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
        if (action == null)
            throw new NullPointerException();
        int hi = getFence(), i = index;
        if (i &lt; hi) {
            index = i + 1;
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E)list.elementData[i];
            action.accept(e);
            if (list.modCount != expectedModCount)
                throw new ConcurrentModificationException();
            return true;
        }
        return false;
    }

    public void forEachRemaining(Consumer&lt;? super E&gt; action) {
        int i, hi, mc; // hoist accesses and checks from loop
        ArrayList&lt;E&gt; lst; Object[] a;
        if (action == null)
            throw new NullPointerException();
        if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) {
            if ((hi = fence) &lt; 0) {
                mc = lst.modCount;
                hi = lst.size;
            }
            else
                mc = expectedModCount;
            if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) {
                for (; i &lt; hi; ++i) {
                    @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i];
                    action.accept(e);
                }
                if (lst.modCount == mc)
                    return;
            }
        }
        throw new ConcurrentModificationException();
    }

    public long estimateSize() {
        return (long) (getFence() - index);
    }

    public int characteristics() {
        return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
    }
}

@Override
public boolean removeIf(Predicate&lt;? super E&gt; filter) {
    Objects.requireNonNull(filter);
    // figure out which elements are to be removed
    // any exception thrown from the filter predicate at this stage
    // will leave the collection unmodified
    int removeCount = 0;
    final BitSet removeSet = new BitSet(size);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        @SuppressWarnings(&quot;unchecked&quot;)
        final E element = (E) elementData[i];
        if (filter.test(element)) {
            removeSet.set(i);
            removeCount++;
        }
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }

    // shift surviving elements left over the spaces left by removed elements
    final boolean anyToRemove = removeCount &gt; 0;
    if (anyToRemove) {
        final int newSize = size - removeCount;
        for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) {
            i = removeSet.nextClearBit(i);
            elementData[j] = elementData[i];
        }
        for (int k=newSize; k &lt; size; k++) {
            elementData[k] = null;  // Let gc do its work
        }
        this.size = newSize;
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    return anyToRemove;
}

@Override
@SuppressWarnings(&quot;unchecked&quot;)
public void replaceAll(UnaryOperator&lt;E&gt; operator) {
    Objects.requireNonNull(operator);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        elementData[i] = operator.apply((E) elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}

@Override
@SuppressWarnings(&quot;unchecked&quot;)
public void sort(Comparator&lt;? super E&gt; c) {
    final int expectedModCount = modCount;
    Arrays.sort((E[]) elementData, 0, size, c);
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}
</code></pre><p>}</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/09/深入理解JVM-chapter2（二）/" rel="next" title="深入理解JVM-chapter2（二）">
                <i class="fa fa-chevron-left"></i> 深入理解JVM-chapter2（二）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/28/易班开发大赛/" rel="prev" title="易班开发大赛">
                易班开发大赛 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Ymon">
            
              <p class="site-author-name" itemprop="name">Ymon</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ymon</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
